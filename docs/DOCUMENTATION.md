<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# govy

```go
import "github.com/nobl9/govy/pkg/govy"
```

Package govy implements a functional API for consistent struct level validation.

## Index

- [Constants](<#constants>)
- [func HasErrorCode\(err error, code ErrorCode\) bool](<#HasErrorCode>)
- [func MapElementName\(mapName, key any\) string](<#MapElementName>)
- [func SliceElementName\(sliceName string, index int\) string](<#SliceElementName>)
- [type CascadeMode](<#CascadeMode>)
- [type ErrorCode](<#ErrorCode>)
- [type MapItem](<#MapItem>)
- [type Predicate](<#Predicate>)
- [type PropertyError](<#PropertyError>)
  - [func NewPropertyError\(propertyName string, propertyValue interface\{\}, errs ...error\) \*PropertyError](<#NewPropertyError>)
  - [func \(e \*PropertyError\) Equal\(cmp \*PropertyError\) bool](<#PropertyError.Equal>)
  - [func \(e \*PropertyError\) Error\(\) string](<#PropertyError.Error>)
  - [func \(e \*PropertyError\) HideValue\(\) \*PropertyError](<#PropertyError.HideValue>)
  - [func \(e \*PropertyError\) PrependParentPropertyName\(name string\) \*PropertyError](<#PropertyError.PrependParentPropertyName>)
- [type PropertyErrors](<#PropertyErrors>)
  - [func \(e PropertyErrors\) Error\(\) string](<#PropertyErrors.Error>)
  - [func \(e PropertyErrors\) HideValue\(\) PropertyErrors](<#PropertyErrors.HideValue>)
- [type PropertyGetter](<#PropertyGetter>)
  - [func GetSelf\[S any\]\(\) PropertyGetter\[S, S\]](<#GetSelf>)
- [type PropertyPlan](<#PropertyPlan>)
- [type PropertyRules](<#PropertyRules>)
  - [func For\[T, S any\]\(getter PropertyGetter\[T, S\]\) PropertyRules\[T, S\]](<#For>)
  - [func ForPointer\[T, S any\]\(getter PropertyGetter\[\*T, S\]\) PropertyRules\[T, S\]](<#ForPointer>)
  - [func Transform\[T, N, S any\]\(getter PropertyGetter\[T, S\], transform Transformer\[T, N\]\) PropertyRules\[N, S\]](<#Transform>)
  - [func \(r PropertyRules\[T, S\]\) Cascade\(mode CascadeMode\) PropertyRules\[T, S\]](<#PropertyRules[T, S].Cascade>)
  - [func \(r PropertyRules\[T, S\]\) HideValue\(\) PropertyRules\[T, S\]](<#PropertyRules[T, S].HideValue>)
  - [func \(r PropertyRules\[T, S\]\) Include\(rules ...Validator\[T\]\) PropertyRules\[T, S\]](<#PropertyRules[T, S].Include>)
  - [func \(r PropertyRules\[T, S\]\) OmitEmpty\(\) PropertyRules\[T, S\]](<#PropertyRules[T, S].OmitEmpty>)
  - [func \(r PropertyRules\[T, S\]\) Required\(\) PropertyRules\[T, S\]](<#PropertyRules[T, S].Required>)
  - [func \(r PropertyRules\[T, S\]\) Rules\(rules ...ruleInterface\[T\]\) PropertyRules\[T, S\]](<#PropertyRules[T, S].Rules>)
  - [func \(r PropertyRules\[T, S\]\) Validate\(st S\) PropertyErrors](<#PropertyRules[T, S].Validate>)
  - [func \(r PropertyRules\[T, S\]\) When\(predicate Predicate\[S\], opts ...WhenOptions\) PropertyRules\[T, S\]](<#PropertyRules[T, S].When>)
  - [func \(r PropertyRules\[T, S\]\) WithExamples\(examples ...string\) PropertyRules\[T, S\]](<#PropertyRules[T, S].WithExamples>)
  - [func \(r PropertyRules\[T, S\]\) WithName\(name string\) PropertyRules\[T, S\]](<#PropertyRules[T, S].WithName>)
- [type PropertyRulesForMap](<#PropertyRulesForMap>)
  - [func ForMap\[M \~map\[K\]V, K comparable, V, S any\]\(getter PropertyGetter\[M, S\]\) PropertyRulesForMap\[M, K, V, S\]](<#ForMap>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) Cascade\(mode CascadeMode\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].Cascade>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) IncludeForItems\(rules ...Validator\[MapItem\[K, V\]\]\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].IncludeForItems>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) IncludeForKeys\(validators ...Validator\[K\]\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].IncludeForKeys>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) IncludeForValues\(rules ...Validator\[V\]\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].IncludeForValues>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) Rules\(rules ...ruleInterface\[M\]\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].Rules>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) RulesForItems\(rules ...ruleInterface\[MapItem\[K, V\]\]\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].RulesForItems>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) RulesForKeys\(rules ...ruleInterface\[K\]\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].RulesForKeys>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) RulesForValues\(rules ...ruleInterface\[V\]\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].RulesForValues>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) Validate\(st S\) PropertyErrors](<#PropertyRulesForMap[M, K, V, S].Validate>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) When\(predicate Predicate\[S\], opts ...WhenOptions\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].When>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) WithExamples\(examples ...string\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].WithExamples>)
  - [func \(r PropertyRulesForMap\[M, K, V, S\]\) WithName\(name string\) PropertyRulesForMap\[M, K, V, S\]](<#PropertyRulesForMap[M, K, V, S].WithName>)
- [type PropertyRulesForSlice](<#PropertyRulesForSlice>)
  - [func ForSlice\[T, S any\]\(getter PropertyGetter\[\[\]T, S\]\) PropertyRulesForSlice\[T, S\]](<#ForSlice>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) Cascade\(mode CascadeMode\) PropertyRulesForSlice\[T, S\]](<#PropertyRulesForSlice[T, S].Cascade>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) IncludeForEach\(rules ...Validator\[T\]\) PropertyRulesForSlice\[T, S\]](<#PropertyRulesForSlice[T, S].IncludeForEach>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) Rules\(rules ...ruleInterface\[\[\]T\]\) PropertyRulesForSlice\[T, S\]](<#PropertyRulesForSlice[T, S].Rules>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) RulesForEach\(rules ...ruleInterface\[T\]\) PropertyRulesForSlice\[T, S\]](<#PropertyRulesForSlice[T, S].RulesForEach>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) Validate\(st S\) PropertyErrors](<#PropertyRulesForSlice[T, S].Validate>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) When\(predicate Predicate\[S\], opts ...WhenOptions\) PropertyRulesForSlice\[T, S\]](<#PropertyRulesForSlice[T, S].When>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) WithExamples\(examples ...string\) PropertyRulesForSlice\[T, S\]](<#PropertyRulesForSlice[T, S].WithExamples>)
  - [func \(r PropertyRulesForSlice\[T, S\]\) WithName\(name string\) PropertyRulesForSlice\[T, S\]](<#PropertyRulesForSlice[T, S].WithName>)
- [type Rule](<#Rule>)
  - [func NewRule\[T any\]\(validate func\(v T\) error\) Rule\[T\]](<#NewRule>)
  - [func \(r Rule\[T\]\) Validate\(v T\) error](<#Rule[T].Validate>)
  - [func \(r Rule\[T\]\) WithDescription\(description string\) Rule\[T\]](<#Rule[T].WithDescription>)
  - [func \(r Rule\[T\]\) WithDetails\(format string, a ...any\) Rule\[T\]](<#Rule[T].WithDetails>)
  - [func \(r Rule\[T\]\) WithErrorCode\(code ErrorCode\) Rule\[T\]](<#Rule[T].WithErrorCode>)
  - [func \(r Rule\[T\]\) WithMessage\(format string, a ...any\) Rule\[T\]](<#Rule[T].WithMessage>)
- [type RuleError](<#RuleError>)
  - [func NewRuleError\(message string, codes ...ErrorCode\) \*RuleError](<#NewRuleError>)
  - [func \(r \*RuleError\) AddCode\(code ErrorCode\) \*RuleError](<#RuleError.AddCode>)
  - [func \(r \*RuleError\) Error\(\) string](<#RuleError.Error>)
  - [func \(r \*RuleError\) HideValue\(stringValue string\) \*RuleError](<#RuleError.HideValue>)
- [type RulePlan](<#RulePlan>)
- [type RuleSet](<#RuleSet>)
  - [func NewRuleSet\[T any\]\(rules ...ruleInterface\[T\]\) RuleSet\[T\]](<#NewRuleSet>)
  - [func \(r RuleSet\[T\]\) Validate\(v T\) error](<#RuleSet[T].Validate>)
  - [func \(r RuleSet\[T\]\) WithDetails\(format string, a ...any\) RuleSet\[T\]](<#RuleSet[T].WithDetails>)
  - [func \(r RuleSet\[T\]\) WithErrorCode\(code ErrorCode\) RuleSet\[T\]](<#RuleSet[T].WithErrorCode>)
- [type Transformer](<#Transformer>)
- [type Validator](<#Validator>)
  - [func New\[S any\]\(props ...propertyRulesInterface\[S\]\) Validator\[S\]](<#New>)
  - [func \(v Validator\[S\]\) InferName\(\) Validator\[S\]](<#Validator[S].InferName>)
  - [func \(v Validator\[S\]\) Validate\(st S\) \*ValidatorError](<#Validator[S].Validate>)
  - [func \(v Validator\[S\]\) When\(predicate Predicate\[S\], opts ...WhenOptions\) Validator\[S\]](<#Validator[S].When>)
  - [func \(v Validator\[S\]\) WithName\(name string\) Validator\[S\]](<#Validator[S].WithName>)
- [type ValidatorError](<#ValidatorError>)
  - [func NewValidatorError\(errs PropertyErrors\) \*ValidatorError](<#NewValidatorError>)
  - [func \(e \*ValidatorError\) Error\(\) string](<#ValidatorError.Error>)
  - [func \(e \*ValidatorError\) WithName\(name string\) \*ValidatorError](<#ValidatorError.WithName>)
- [type ValidatorPlan](<#ValidatorPlan>)
  - [func Plan\[S any\]\(v Validator\[S\]\) \*ValidatorPlan](<#Plan>)
- [type WhenOptions](<#WhenOptions>)
  - [func WhenDescription\(format string, a ...interface\{\}\) WhenOptions](<#WhenDescription>)


## Constants

<a name="ErrorCodeSeparator"></a>

```go
const (
    ErrorCodeSeparator = ":"
)
```

<a name="HasErrorCode"></a>
## func [HasErrorCode](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L208>)

```go
func HasErrorCode(err error, code ErrorCode) bool
```

HasErrorCode checks if an error contains given [ErrorCode](<#ErrorCode>). It supports all govy errors.

<details><summary>Example</summary>
<p>

To inspect if an error contains a given [govy.ErrorCode](<#ErrorCode>), use [govy.HasErrorCode](<#HasErrorCode>) function. This function will also return true if the expected [govy.ErrorCode](<#ErrorCode>) is part of a chain of wrapped error codes. In this example we're dealing with two error code chains:

- 'teacher\_name:string\_length'
- 'teacher\_name:string\_match\_regexp'

```go
package main

import (
	"fmt"
	"regexp"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	teacherNameRule := govy.NewRuleSet(
		rules.StringLength(1, 5),
		rules.StringMatchRegexp(regexp.MustCompile("^(Tom|Jerry)$")),
	).
		WithErrorCode("teacher_name")

	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Rules(teacherNameRule),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jonathan",
		Age:  51 * year,
	}

	err := v.Validate(teacher)
	if err != nil {
		for _, code := range []govy.ErrorCode{
			"teacher_name",
			"string_length",
			"string_match_regexp",
		} {
			if govy.HasErrorCode(err, code) {
				fmt.Println("Has error code:", code)
			}
		}
	}

}
```

#### Output

```
Has error code: teacher_name
Has error code: string_length
Has error code: string_match_regexp
```

</p>
</details>

<a name="MapElementName"></a>
## func [MapElementName](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L169>)

```go
func MapElementName(mapName, key any) string
```

MapElementName generates a name for a map element denoted by its key.

<a name="SliceElementName"></a>
## func [SliceElementName](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L108>)

```go
func SliceElementName(sliceName string, index int) string
```

SliceElementName generates a name for a slice element.

<a name="CascadeMode"></a>
## type [CascadeMode](<https://github.com/nobl9/govy/blob/main/pkg/govy/cascade_mode.go#L4>)

CascadeMode defines how validation should behave when an error is encountered.

```go
type CascadeMode uint
```

<a name="CascadeModeContinue"></a>

```go
const (
    // CascadeModeContinue will continue validation after first error.
    CascadeModeContinue CascadeMode = iota
    // CascadeModeStop will stop validation on first error encountered.
    CascadeModeStop
)
```

<a name="ErrorCode"></a>
## type [ErrorCode](<https://github.com/nobl9/govy/blob/main/pkg/govy/error_code.go#L5>)

ErrorCode is a unique string that represents a specific [RuleError](<#RuleError>). It can be used to precisely identify the error without inspecting its message.

```go
type ErrorCode = string
```

<a name="ErrorCodeTransform"></a>

```go
const (
    ErrorCodeTransform ErrorCode = "transform"
)
```

<a name="MapItem"></a>
## type [MapItem](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L35-L38>)

MapItem is a tuple container for map's key and value pair.

```go
type MapItem[K comparable, V any] struct {
    Key   K
    Value V
}
```

<a name="Predicate"></a>
## type [Predicate](<https://github.com/nobl9/govy/blob/main/pkg/govy/predicate.go#L16>)

Predicate defines a function that returns a boolean value.

```go
type Predicate[T any] func(T) bool
```

<a name="PropertyError"></a>
## type [PropertyError](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L110-L119>)



```go
type PropertyError struct {
    PropertyName  string `json:"propertyName"`
    PropertyValue string `json:"propertyValue"`
    // IsKeyError is set to true if the error was created through map key validation.
    // PropertyValue in this scenario will be the key value, equal to the last element of PropertyName path.
    IsKeyError bool `json:"isKeyError,omitempty"`
    // IsSliceElementError is set to true if the error was created through slice element validation.
    IsSliceElementError bool         `json:"isSliceElementError,omitempty"`
    Errors              []*RuleError `json:"errors"`
}
```

<a name="NewPropertyError"></a>
### func [NewPropertyError](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L102>)

```go
func NewPropertyError(propertyName string, propertyValue interface{}, errs ...error) *PropertyError
```



<details><summary>Example</summary>
<p>

Sometimes you need top level context, but you want to scope the error to a specific, nested property. One of the ways to do that is to use [govy.NewPropertyError](<#NewPropertyError>) and return [govy.PropertyError](<#PropertyError>) from your validation rule. Note that you can still use [govy.ErrorCode](<#ErrorCode>) and pass [govy.RuleError](<#RuleError>) to the constructor. You can pass any number of [govy.RuleError](<#RuleError>).

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	v := govy.New(
		govy.For(govy.GetSelf[Teacher]()).
			Rules(govy.NewRule(func(t Teacher) error {
				if t.Name == "Jake" {
					return govy.NewPropertyError(
						"name",
						t.Name,
						govy.NewRuleError("name cannot be Jake", "error_code_jake"),
						govy.NewRuleError("you can pass me too!"))
				}
				return nil
			})),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jake",
		Age:  51 * year,
	}

	err := v.Validate(teacher)
	if err != nil {
		propertyErrors := err.Errors
		ruleErrors := propertyErrors[0].Errors
		fmt.Printf("Error code: %s\n\n", ruleErrors[0].Code)
		fmt.Println(err)
	}

}
```

#### Output

```
Error code: error_code_jake

Validation for Teacher has failed for the following properties:
  - 'name' with value 'Jake':
    - name cannot be Jake
    - you can pass me too!
```

</p>
</details>

<a name="PropertyError.Equal"></a>
### func \(\*PropertyError\) [Equal](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L141>)

```go
func (e *PropertyError) Equal(cmp *PropertyError) bool
```

Equal checks if two [PropertyError](<#PropertyError>) are equal.

<a name="PropertyError.Error"></a>
### func \(\*PropertyError\) [Error](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L121>)

```go
func (e *PropertyError) Error() string
```



<a name="PropertyError.HideValue"></a>
### func \(\*PropertyError\) [HideValue](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L159>)

```go
func (e *PropertyError) HideValue() *PropertyError
```

HideValue hides the property value from each of the \[PropertyError.Errors\].

<a name="PropertyError.PrependParentPropertyName"></a>
### func \(\*PropertyError\) [PrependParentPropertyName](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L149>)

```go
func (e *PropertyError) PrependParentPropertyName(name string) *PropertyError
```

PrependParentPropertyName prepends a given name to the \[PropertyError.PropertyName\].

<a name="PropertyErrors"></a>
## type [PropertyErrors](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L47>)

PropertyErrors is a slice of [PropertyError](<#PropertyError>).

```go
type PropertyErrors []*PropertyError
```

<a name="PropertyErrors.Error"></a>
### func \(PropertyErrors\) [Error](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L49>)

```go
func (e PropertyErrors) Error() string
```



<a name="PropertyErrors.HideValue"></a>
### func \(PropertyErrors\) [HideValue](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L55>)

```go
func (e PropertyErrors) HideValue() PropertyErrors
```



<a name="PropertyGetter"></a>
## type [PropertyGetter](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L75>)

PropertyGetter is a function that extracts a property value of type T from a given parent value of type S.

```go
type PropertyGetter[T, S any] func(S) T
```

<a name="GetSelf"></a>
### func [GetSelf](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L66>)

```go
func GetSelf[S any]() PropertyGetter[S, S]
```

GetSelf is a convenience method for extracting 'self' property of a validated value.

<details><summary>Example</summary>
<p>

If you want to access the value of the entity you're writing the [govy.Validator](<#Validator>) for, you can use [govy.GetSelf](<#GetSelf>) function which is a convenience [govy.PropertyGetter](<#PropertyGetter>) that returns self. Note that we don't call [govy.PropertyRules.WithName](<#PropertyRules.WithName>) here, as we're comparing two properties in our top level, \[Teacher\] scope.

You can provide your own rules using [govy.NewRule](<#NewRule>) constructor. It returns new [govy.Rule](<#Rule>) instance which wraps your validation function.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	customRule := govy.NewRule(func(v Teacher) error {
		return fmt.Errorf("now I have access to the whole teacher")
	})

	v := govy.New(
		govy.For(govy.GetSelf[Teacher]()).
			Rules(customRule),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jake",
		Age:  51 * year,
	}

	err := v.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - now I have access to the whole teacher
```

</p>
</details>

<a name="PropertyPlan"></a>
## type [PropertyPlan](<https://github.com/nobl9/govy/blob/main/pkg/govy/plan.go#L18-L31>)

PropertyPlan is a validation plan for a single [PropertyRules](<#PropertyRules>).

```go
type PropertyPlan struct {
    // Path is a JSON path to the property.
    Path string `json:"path"`
    // Type is a Go type name of the property.
    Type string `json:"type"`
    // Package is the full package path of the Type.
    Package string `json:"package,omitempty"`
    // IsOptional indicates if the property was marked with [PropertyRules.OmitEmpty].
    IsOptional bool `json:"isOptional,omitempty"`
    // IsHidden indicates if the property was marked with [PropertyRules.HideValue].
    IsHidden bool       `json:"isHidden,omitempty"`
    Examples []string   `json:"examples,omitempty"`
    Rules    []RulePlan `json:"rules,omitempty"`
}
```

<a name="PropertyRules"></a>
## type [PropertyRules](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L91-L105>)

PropertyRules is responsible for validating a single property. It is a collection of rules, predicates, and other properties that define how the property should be validated. IT is the middle\-level building block of the validation process, aggregated by [Validator](<#Validator>) and aggregating [Rule](<#Rule>).

```go
type PropertyRules[T, S any] struct {
    // contains filtered or unexported fields
}
```

<a name="For"></a>
### func [For](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L12>)

```go
func For[T, S any](getter PropertyGetter[T, S]) PropertyRules[T, S]
```

For creates a new [PropertyRules](<#PropertyRules>) instance for the property which value is extracted through [PropertyGetter](<#PropertyGetter>) function.

<a name="ForPointer"></a>
### func [ForPointer](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L27>)

```go
func ForPointer[T, S any](getter PropertyGetter[*T, S]) PropertyRules[T, S]
```

ForPointer accepts a getter function returning a pointer and wraps its call in order to safely extract the value under the pointer or return a zero value for a give type T. If required is set to true, the nil pointer value will result in an error and the validation will not proceed.

<details><summary>Example</summary>
<p>

[govy.For](<#For>) constructor creates new [govy.PropertyRules](<#PropertyRules>) instance. It's only argument, [govy.PropertyGetter](<#PropertyGetter>) is used to extract the property value. It works fine for direct values, but falls short when working with pointers. Often times we use pointers to indicate that a property is optional, or we want to discern between nil and zero values. In either case we want our validation rules to work on direct values, not the pointer, otherwise we'd have to always check if pointer \!= nil.

[govy.ForPointer](<#ForPointer>) constructor can be used to solve this problem and allow us to work with the underlying value in our rules. Under the hood it wraps [govy.PropertyGetter](<#PropertyGetter>) and safely extracts the underlying value. If the value was nil, it will not attempt to evaluate any rules for this property. The rationale for that is it doesn't make sense to evaluate any rules for properties which are essentially empty. The only rule that makes sense in this context is to ensure the property is required. We'll learn about a way to achieve that in the next example: \[ExamplePropertyRules\_Required\].

Let's define a rule for \[Teacher.MiddleName\] property. Not everyone has to have a middle name, that's why we've defined this field as a pointer to string, rather than a string itself.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	v := govy.New(
		govy.ForPointer(func(t Teacher) *string { return t.MiddleName }).
			WithName("middleName").
			Rules(rules.StringMaxLength(5)),
	).WithName("Teacher")

	middleName := "Thaddeus"
	teacher := Teacher{
		Name:       "Jake",
		Age:        51 * year,
		MiddleName: &middleName,
	}

	err := v.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'middleName' with value 'Thaddeus':
    - length must be less than or equal to 5
```

</p>
</details>

<a name="Transform"></a>
### func [Transform](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L46>)

```go
func Transform[T, N, S any](getter PropertyGetter[T, S], transform Transformer[T, N]) PropertyRules[N, S]
```

Transform transforms value from one type to another. Value returned by [PropertyGetter](<#PropertyGetter>) is transformed through [Transformer](<#Transformer>) function. If [Transformer](<#Transformer>) returns an error, the validation will not proceed and transformation error will be reported. [Transformer](<#Transformer>) is only called if [PropertyGetter](<#PropertyGetter>) returns a non\-zero value.

<a name="PropertyRules[T, S].Cascade"></a>
### func \(PropertyRules\[T, S\]\) [Cascade](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L219>)

```go
func (r PropertyRules[T, S]) Cascade(mode CascadeMode) PropertyRules[T, S]
```

Cascade sets the [CascadeMode](<#CascadeMode>) for the property, which controls the flow of evaluating the validation rules.

<details><summary>Example</summary>
<p>

To customize how [govy.Rule](<#Rule>) are evaluated use [govy.PropertyRules.Cascade](<#PropertyRules.Cascade>). Use [govy.CascadeModeStop](<#CascadeModeContinue>) to stop validation after the first error. If you wish to revert to the default behavior, use [govy.CascadeModeContinue](<#CascadeModeContinue>).

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	alwaysFailingRule := govy.NewRule(func(string) error {
		return fmt.Errorf("always fails")
	})

	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Cascade(govy.CascadeModeStop).
			Rules(rules.NEQ("Jerry")).
			Rules(alwaysFailingRule),
	).WithName("Teacher")

	for _, name := range []string{"Tom", "Jerry"} {
		teacher := Teacher{Name: name}
		err := v.Validate(teacher)
		if err != nil {
			fmt.Println(err)
		}
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'name' with value 'Tom':
    - always fails
Validation for Teacher has failed for the following properties:
  - 'name' with value 'Jerry':
    - should be not equal to 'Jerry'
```

</p>
</details>

<a name="PropertyRules[T, S].HideValue"></a>
### func \(PropertyRules\[T, S\]\) [HideValue](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L212>)

```go
func (r PropertyRules[T, S]) HideValue() PropertyRules[T, S]
```

HideValue hides the property value in the error message. It's useful when the value is sensitive and should not be exposed.

<a name="PropertyRules[T, S].Include"></a>
### func \(PropertyRules\[T, S\]\) [Include](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L184>)

```go
func (r PropertyRules[T, S]) Include(rules ...Validator[T]) PropertyRules[T, S]
```

Include embeds specified [Validator](<#Validator>) and its [PropertyRules](<#PropertyRules>) into the property.

<details><summary>Example</summary>
<p>

So far we've defined validation rules for simple, top\-level properties. What If we want to define validation rules for nested properties? We can use [govy.PropertyRules.Include](<#PropertyRules.Include>) to include another [govy.Validator](<#Validator>) in our [govy.PropertyRules](<#PropertyRules>).

Let's extend our \[Teacher\] struct to include a nested \[University\] property. \[University\] in of itself is another struct with its own validation rules.

Notice how the nested property path is automatically built for you, each segment separated by a dot.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	universityValidation := govy.New(
		govy.For(func(u University) string { return u.Address }).
			WithName("address").
			Required(),
	)
	teacherValidation := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Rules(rules.EQ("Tom")),
		govy.For(func(t Teacher) University { return t.University }).
			WithName("university").
			Include(universityValidation),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jerry",
		Age:  51 * year,
		University: University{
			Name:    "Poznan University of Technology",
			Address: "",
		},
	}

	err := teacherValidation.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'name' with value 'Jerry':
    - should be equal to 'Tom'
  - 'university.address':
    - property is required but was empty
```

</p>
</details>

<a name="PropertyRules[T, S].OmitEmpty"></a>
### func \(PropertyRules\[T, S\]\) [OmitEmpty](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L205>)

```go
func (r PropertyRules[T, S]) OmitEmpty() PropertyRules[T, S]
```

OmitEmpty sets the property rules to be omitted if its value is its type's zero value.

<details><summary>Example</summary>
<p>

While [govy.ForPointer](<#ForPointer>) will by default omit validation for nil pointers, it might be useful to have a similar behavior for optional properties which are direct values. [govy.PropertyRules.OmitEmpty](<#PropertyRules.OmitEmpty>) will do the trick.

NOTE: [govy.PropertyRules.OmitEmpty](<#PropertyRules.OmitEmpty>) will have no effect on pointers handled by [govy.ForPointer](<#ForPointer>), as they already behave in the same way.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	alwaysFailingRule := govy.NewRule(func(string) error {
		return fmt.Errorf("always fails")
	})

	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			OmitEmpty().
			Rules(alwaysFailingRule),
		govy.ForPointer(func(t Teacher) *string { return t.MiddleName }).
			WithName("middleName").
			Rules(alwaysFailingRule),
	).WithName("Teacher")

	teacher := Teacher{
		Name:       "",
		Age:        51 * year,
		MiddleName: nil,
	}

	err := v.Validate(teacher)
	if err == nil {
		fmt.Println("no error! we skipped 'name' validation and 'middleName' is implicitly skipped")
	}

}
```

#### Output

```
no error! we skipped 'name' validation and 'middleName' is implicitly skipped
```

</p>
</details>

<a name="PropertyRules[T, S].Required"></a>
### func \(PropertyRules\[T, S\]\) [Required](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L199>)

```go
func (r PropertyRules[T, S]) Required() PropertyRules[T, S]
```

Required sets the property as required. If the property is its type's zero value a \[rules.ErrorCodeRequired\] will be returned.

<details><summary>Example</summary>
<p>

By default, when [govy.PropertyRules](<#PropertyRules>) is constructed using [govy.ForPointer](<#ForPointer>) it will skip validation of the property if the pointer is nil. To enforce a value is set for pointer use [govy.PropertyRules.Required](<#PropertyRules.Required>).

You may ask yourself why not just use \[rules.Required\] rule instead? If we were to do that, we'd be forced to operate on pointer in all of our rules. Other than checking if the pointer is nil, there aren't any rules which would benefit from working on the pointer instead of the underlying value.

If you want to also make sure the underlying value is filled, i.e. it's not a zero value, you can also use \[rules.Required\] rule on top of [govy.PropertyRules.Required](<#PropertyRules.Required>).

[govy.PropertyRules.Required](<#PropertyRules.Required>) when used with [govy.For](<#For>) constructor, will ensure the property does not contain a zero value.

NOTE: [govy.PropertyRules.Required](<#PropertyRules.Required>) is introducing a short circuit. If the assertion fails, validation will stop and return \[govy.govy.ErrorCodeRequired\]. None of the rules you've defined would be evaluated.

NOTE: Placement of [govy.PropertyRules.Required](<#PropertyRules.Required>) does not matter, it's not evaluated in a sequential loop, unlike standard [govy.Rule](<#Rule>). However, we recommend you always place it below [govy.PropertyRules.WithName](<#PropertyRules.WithName>) to make your rules more readable.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	alwaysFailingRule := govy.NewRule(func(string) error {
		return fmt.Errorf("always fails")
	})

	v := govy.New(
		govy.ForPointer(func(t Teacher) *string { return t.MiddleName }).
			WithName("middleName").
			Required().
			Rules(alwaysFailingRule),
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Required().
			Rules(alwaysFailingRule),
	).WithName("Teacher")

	teacher := Teacher{
		Name:       "",
		Age:        51 * year,
		MiddleName: nil,
	}

	err := v.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'middleName':
    - property is required but was empty
  - 'name':
    - property is required but was empty
```

</p>
</details>

<a name="PropertyRules[T, S].Rules"></a>
### func \(PropertyRules\[T, S\]\) [Rules](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L178>)

```go
func (r PropertyRules[T, S]) Rules(rules ...ruleInterface[T]) PropertyRules[T, S]
```

Rules associates provided [Rule](<#Rule>) with the property.

<a name="PropertyRules[T, S].Validate"></a>
### func \(PropertyRules\[T, S\]\) [Validate](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L108>)

```go
func (r PropertyRules[T, S]) Validate(st S) PropertyErrors
```

Validate validates the property value using provided rules.

<a name="PropertyRules[T, S].When"></a>
### func \(PropertyRules\[T, S\]\) [When](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L192>)

```go
func (r PropertyRules[T, S]) When(predicate Predicate[S], opts ...WhenOptions) PropertyRules[T, S]
```

When defines a [Predicate](<#Predicate>) which determines when the rules for this property should be evaluated. It can be called multiple times to set multiple predicates. Additionally, it accepts [WhenOptions](<#WhenOptions>) which customizes the behavior of the predicate.

<details><summary>Example</summary>
<p>

To only run property validation on condition, use [govy.PropertyRules.When](<#PropertyRules.When>). Predicates set through [govy.PropertyRules.When](<#PropertyRules.When>) are evaluated in the order they are provided. If any predicate is not met, validation rules are not evaluated for the whole [govy.PropertyRules](<#PropertyRules>).

It's recommended to define [govy.PropertyRules.When](<#PropertyRules.When>) before [govy.PropertyRules.Rules](<#PropertyRules.Rules>) declaration.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			When(func(t Teacher) bool { return t.Name == "Jerry" }).
			Rules(rules.NEQ("Jerry")),
	).WithName("Teacher")

	for _, name := range []string{"Tom", "Jerry", "Mickey"} {
		teacher := Teacher{Name: name}
		err := v.Validate(teacher)
		if err != nil {
			fmt.Println(err)
		}
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'name' with value 'Jerry':
    - should be not equal to 'Jerry'
```

</p>
</details>

<a name="PropertyRules[T, S].WithExamples"></a>
### func \(PropertyRules\[T, S\]\) [WithExamples](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L172>)

```go
func (r PropertyRules[T, S]) WithExamples(examples ...string) PropertyRules[T, S]
```

WithExamples sets the examples for the property.

<a name="PropertyRules[T, S].WithName"></a>
### func \(PropertyRules\[T, S\]\) [WithName](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L166>)

```go
func (r PropertyRules[T, S]) WithName(name string) PropertyRules[T, S]
```

WithName sets the name of the property. If the name was inferred, it will be overridden.

<details><summary>Example</summary>
<p>

So far we've been using a very simple [govy.PropertyRules](<#PropertyRules>) instance:

```
validation.For(func(t Teacher) string { return t.Name }).
	Rules(validation.NewRule(func(name string) error { return fmt.Errorf("always fails") }))
```

The error message returned by this property rule does not tell us which property is failing. Let's change that by adding property name using [govy.PropertyRules.WithName](<#PropertyRules.WithName>).

We can also change the [govy.Rule](<#Rule>) to be something more real. govy comes with a number of predefined [govy.Rule](<#Rule>), we'll use \[rules.EQ\] which accepts a single argument, value to compare with.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Rules(rules.EQ("Tom")),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jake",
		Age:  51 * year,
	}

	err := v.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'name' with value 'Jake':
    - should be equal to 'Tom'
```

</p>
</details>

<a name="PropertyRulesForMap"></a>
## type [PropertyRulesForMap](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L23-L32>)

PropertyRulesForMap is responsible for validating a single property.

```go
type PropertyRulesForMap[M ~map[K]V, K comparable, V, S any] struct {
    // contains filtered or unexported fields
}
```

<a name="ForMap"></a>
### func [ForMap](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L11>)

```go
func ForMap[M ~map[K]V, K comparable, V, S any](getter PropertyGetter[M, S]) PropertyRulesForMap[M, K, V, S]
```

ForMap creates a new [PropertyRulesForMap](<#PropertyRulesForMap>) instance for a map property which value is extracted through [PropertyGetter](<#PropertyGetter>) function.

<details><summary>Example</summary>
<p>

When dealing with maps there are three forms of iteration: \- keys \- values \- key\-value pairs \(items\)

You can use [govy.ForMap](<#ForMap>) function to define rules for all the aforementioned iterators. It returns a new struct [govy.PropertyRulesForMap](<#PropertyRulesForMap>) which behaves similar to [govy.PropertyRulesForSlice](<#PropertyRulesForSlice>)..

To define rules for keys use: \- [govy.PropertyRulesForMap.RulesForKeys](<#PropertyRulesForMap.RulesForKeys>) \- [govy.PropertyRulesForMap.IncludeForKeys](<#PropertyRulesForMap.IncludeForKeys>) \- [govy.PropertyRulesForMap.RulesForValues](<#PropertyRulesForMap.RulesForValues>) \- [govy.PropertyRulesForMap.IncludeForValues](<#PropertyRulesForMap.IncludeForValues>) \- [govy.PropertyRulesForMap.RulesForItems](<#PropertyRulesForMap.RulesForItems>) \- [govy.PropertyRulesForMap.IncludeForItems](<#PropertyRulesForMap.IncludeForItems>) These work exactly the same way as [govy.PropertyRules.Rules](<#PropertyRules.Rules>) and [govy.PropertyRules.Include](<#PropertyRules.Include>) verifying each map's key, value or [govy.MapItem](<#MapItem>).

[govy.PropertyRulesForMap.Rules](<#PropertyRulesForMap.Rules>) is in turn used to define rules for the whole map.

NOTE: [govy.PropertyRulesForMap](<#PropertyRulesForMap>) does not implement Include function for the whole map.

In the below example, we're defining that student index to \[Teacher\] map: \- Must have at most 2 elements \(map\). \- Keys must have a length of 9 \(keys\). \- Eve cannot be a teacher for any student \(values\). \- Joan cannot be a teacher for student with index 918230013 \(items\).

Notice that property path for maps has the following format: \<map\_name\>.\<key\>.\<map\_property\_name\>

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

type Tutoring struct {
	StudentIndexToTeacher map[string]Teacher `json:"studentIndexToTeacher"`
}

func main() {
	teacherValidator := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Rules(rules.NEQ("Eve")),
	)
	tutoringValidator := govy.New(
		govy.ForMap(func(t Tutoring) map[string]Teacher { return t.StudentIndexToTeacher }).
			WithName("students").
			Rules(
				rules.MapMaxLength[map[string]Teacher](2),
			).
			RulesForKeys(
				rules.StringLength(9, 9),
			).
			IncludeForValues(teacherValidator).
			RulesForItems(govy.NewRule(func(v govy.MapItem[string, Teacher]) error {
				if v.Key == "918230013" && v.Value.Name == "Joan" {
					return govy.NewRuleError(
						"Joan cannot be a teacher for student with index 918230013",
						"joan_teacher",
					)
				}
				return nil
			})),
	)

	tutoring := Tutoring{
		StudentIndexToTeacher: map[string]Teacher{
			"918230013":  {Name: "Joan"},
			"9182300123": {Name: "Eve"},
			"918230014":  {Name: "Joan"},
		},
	}

	err := tutoringValidator.Validate(tutoring)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation has failed for the following properties:
  - 'students' with value '{"9182300123":{"name":"Eve","age":0,"students":null,"university":{"name":"","address":""}},"91823001...':
    - length must be less than or equal to 2
  - 'students.9182300123' with key '9182300123':
    - length must be between 9 and 9
  - 'students.9182300123.name' with value 'Eve':
    - should be not equal to 'Eve'
  - 'students.918230013' with value '{"name":"Joan","age":0,"students":null,"university":{"name":"","address":""}}':
    - Joan cannot be a teacher for student with index 918230013
```

</p>
</details>

<a name="PropertyRulesForMap[M, K, V, S].Cascade"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [Cascade](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L140>)

```go
func (r PropertyRulesForMap[M, K, V, S]) Cascade(mode CascadeMode) PropertyRulesForMap[M, K, V, S]
```

Cascade =\> refer to [PropertyRules.Cascade](<#PropertyRules.Cascade>) documentation.

<a name="PropertyRulesForMap[M, K, V, S].IncludeForItems"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [IncludeForItems](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L132-L134>)

```go
func (r PropertyRulesForMap[M, K, V, S]) IncludeForItems(rules ...Validator[MapItem[K, V]]) PropertyRulesForMap[M, K, V, S]
```

IncludeForItems associates specified [Validator](<#Validator>) and its [PropertyRules](<#PropertyRules>) with [MapItem](<#MapItem>). It allows validating both key and value in conjunction.

<a name="PropertyRulesForMap[M, K, V, S].IncludeForKeys"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [IncludeForKeys](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L119>)

```go
func (r PropertyRulesForMap[M, K, V, S]) IncludeForKeys(validators ...Validator[K]) PropertyRulesForMap[M, K, V, S]
```

IncludeForKeys associates specified [Validator](<#Validator>) and its [PropertyRules](<#PropertyRules>) with map's keys.

<a name="PropertyRulesForMap[M, K, V, S].IncludeForValues"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [IncludeForValues](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L125>)

```go
func (r PropertyRulesForMap[M, K, V, S]) IncludeForValues(rules ...Validator[V]) PropertyRulesForMap[M, K, V, S]
```

IncludeForValues associates specified [Validator](<#Validator>) and its [PropertyRules](<#PropertyRules>) with map's values.

<a name="PropertyRulesForMap[M, K, V, S].Rules"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [Rules](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L104>)

```go
func (r PropertyRulesForMap[M, K, V, S]) Rules(rules ...ruleInterface[M]) PropertyRulesForMap[M, K, V, S]
```

Rules adds [Rule](<#Rule>) for the whole map.

<a name="PropertyRulesForMap[M, K, V, S].RulesForItems"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [RulesForItems](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L96-L98>)

```go
func (r PropertyRulesForMap[M, K, V, S]) RulesForItems(rules ...ruleInterface[MapItem[K, V]]) PropertyRulesForMap[M, K, V, S]
```

RulesForItems adds [Rule](<#Rule>) for [MapItem](<#MapItem>). It allows validating both key and value in conjunction.

<a name="PropertyRulesForMap[M, K, V, S].RulesForKeys"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [RulesForKeys](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L83>)

```go
func (r PropertyRulesForMap[M, K, V, S]) RulesForKeys(rules ...ruleInterface[K]) PropertyRulesForMap[M, K, V, S]
```

RulesForKeys adds [Rule](<#Rule>) for map's keys.

<a name="PropertyRulesForMap[M, K, V, S].RulesForValues"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [RulesForValues](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L89>)

```go
func (r PropertyRulesForMap[M, K, V, S]) RulesForValues(rules ...ruleInterface[V]) PropertyRulesForMap[M, K, V, S]
```

RulesForValues adds [Rule](<#Rule>) for map's values.

<a name="PropertyRulesForMap[M, K, V, S].Validate"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [Validate](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L41>)

```go
func (r PropertyRulesForMap[M, K, V, S]) Validate(st S) PropertyErrors
```

Validate executes each of the rules sequentially and aggregates the encountered errors.

<a name="PropertyRulesForMap[M, K, V, S].When"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [When](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L110-L113>)

```go
func (r PropertyRulesForMap[M, K, V, S]) When(predicate Predicate[S], opts ...WhenOptions) PropertyRulesForMap[M, K, V, S]
```

When =\> refer to [PropertyRules.When](<#PropertyRules.When>) documentation.

<a name="PropertyRulesForMap[M, K, V, S].WithExamples"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [WithExamples](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L77>)

```go
func (r PropertyRulesForMap[M, K, V, S]) WithExamples(examples ...string) PropertyRulesForMap[M, K, V, S]
```

WithExamples =\> refer to [PropertyRules.WithExamples](<#PropertyRules.WithExamples>) documentation.

<a name="PropertyRulesForMap[M, K, V, S].WithName"></a>
### func \(PropertyRulesForMap\[M, K, V, S\]\) [WithName](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_map.go#L71>)

```go
func (r PropertyRulesForMap[M, K, V, S]) WithName(name string) PropertyRulesForMap[M, K, V, S]
```

WithName =\> refer to [PropertyRules.When](<#PropertyRules.When>) documentation.

<a name="PropertyRulesForSlice"></a>
## type [PropertyRulesForSlice](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L19-L26>)

PropertyRulesForSlice is responsible for validating a single property.

```go
type PropertyRulesForSlice[T, S any] struct {
    // contains filtered or unexported fields
}
```

<a name="ForSlice"></a>
### func [ForSlice](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L9>)

```go
func ForSlice[T, S any](getter PropertyGetter[[]T, S]) PropertyRulesForSlice[T, S]
```

ForSlice creates a new [PropertyRulesForSlice](<#PropertyRulesForSlice>) instance for a slice property which value is extracted through [PropertyGetter](<#PropertyGetter>) function.

<details><summary>Example</summary>
<p>

When dealing with slices we often want to both validate the whole slice and each of its elements. You can use [govy.ForSlice](<#ForSlice>) function to do just that. It returns a new struct [govy.PropertyRulesForSlice](<#PropertyRulesForSlice>) which behaves exactly the same as [govy.PropertyRules](<#PropertyRules>), but extends its API slightly.

To define rules for each element use: \- [govy.PropertyRulesForSlice.RulesForEach](<#PropertyRulesForSlice.RulesForEach>) \- [govy.PropertyRulesForSlice.IncludeForEach](<#PropertyRulesForSlice.IncludeForEach>) These work exactly the same way as [govy.PropertyRules.Rules](<#PropertyRules.Rules>) and [govy.PropertyRules.Include](<#PropertyRules.Include>) verifying each slice element.

[govy.PropertyRulesForSlice.Rules](<#PropertyRulesForSlice.Rules>) is in turn used to define rules for the whole slice.

NOTE: [govy.PropertyRulesForSlice](<#PropertyRulesForSlice>) does not implement Include function for the whole slice.

In the below example, we're defining that students slice must have at most 2 elements and that each element's index must be unique. For each element we're also including \[Student\] [govy.Validator](<#Validator>). Notice that property path for slices has the following format: \<slice\_name\>\[\<index\>\].\<slice\_property\_name\>

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	studentValidator := govy.New(
		govy.For(func(s Student) string { return s.Index }).
			WithName("index").
			Rules(rules.StringLength(9, 9)),
	)
	teacherValidator := govy.New(
		govy.ForSlice(func(t Teacher) []Student { return t.Students }).
			WithName("students").
			Rules(
				rules.SliceMaxLength[[]Student](2),
				rules.SliceUnique(func(v Student) string { return v.Index })).
			IncludeForEach(studentValidator),
	).When(func(t Teacher) bool { return t.Age < 50 })

	teacher := Teacher{
		Name: "John",
		Students: []Student{
			{Index: "918230014"},
			{Index: "9182300123"},
			{Index: "918230014"},
		},
	}

	err := teacherValidator.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation has failed for the following properties:
  - 'students' with value '[{"index":"918230014"},{"index":"9182300123"},{"index":"918230014"}]':
    - length must be less than or equal to 2
    - elements are not unique, index 0 collides with index 2
  - 'students[1].index' with value '9182300123':
    - length must be between 9 and 9
```

</p>
</details>

<a name="PropertyRulesForSlice[T, S].Cascade"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [Cascade](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L88>)

```go
func (r PropertyRulesForSlice[T, S]) Cascade(mode CascadeMode) PropertyRulesForSlice[T, S]
```

Cascade =\> refer to [PropertyRules.Cascade](<#PropertyRules.Cascade>) documentation.

<a name="PropertyRulesForSlice[T, S].IncludeForEach"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [IncludeForEach](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L82>)

```go
func (r PropertyRulesForSlice[T, S]) IncludeForEach(rules ...Validator[T]) PropertyRulesForSlice[T, S]
```

IncludeForEach associates specified [Validator](<#Validator>) and its [PropertyRules](<#PropertyRules>) with each element of the slice.

<a name="PropertyRulesForSlice[T, S].Rules"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [Rules](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L70>)

```go
func (r PropertyRulesForSlice[T, S]) Rules(rules ...ruleInterface[[]T]) PropertyRulesForSlice[T, S]
```

Rules adds [Rule](<#Rule>) for the whole slice.

<a name="PropertyRulesForSlice[T, S].RulesForEach"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [RulesForEach](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L64>)

```go
func (r PropertyRulesForSlice[T, S]) RulesForEach(rules ...ruleInterface[T]) PropertyRulesForSlice[T, S]
```

RulesForEach adds [Rule](<#Rule>) for each element of the slice.

<a name="PropertyRulesForSlice[T, S].Validate"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [Validate](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L29>)

```go
func (r PropertyRulesForSlice[T, S]) Validate(st S) PropertyErrors
```

Validate executes each of the rules sequentially and aggregates the encountered errors.

<a name="PropertyRulesForSlice[T, S].When"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [When](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L76>)

```go
func (r PropertyRulesForSlice[T, S]) When(predicate Predicate[S], opts ...WhenOptions) PropertyRulesForSlice[T, S]
```

When =\> refer to [PropertyRules.When](<#PropertyRules.When>) documentation.

<a name="PropertyRulesForSlice[T, S].WithExamples"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [WithExamples](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L58>)

```go
func (r PropertyRulesForSlice[T, S]) WithExamples(examples ...string) PropertyRulesForSlice[T, S]
```

WithExamples =\> refer to [PropertyRules.WithExamples](<#PropertyRules.WithExamples>) documentation.

<a name="PropertyRulesForSlice[T, S].WithName"></a>
### func \(PropertyRulesForSlice\[T, S\]\) [WithName](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules_for_slice.go#L52>)

```go
func (r PropertyRulesForSlice[T, S]) WithName(name string) PropertyRulesForSlice[T, S]
```

WithName =\> refer to [PropertyRules.WithName](<#PropertyRules.WithName>) documentation.

<a name="Rule"></a>
## type [Rule](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L22-L28>)

Rule is the basic validation building block. It evaluates the provided validation function and enhances it with optional [ErrorCode](<#ErrorCode>) and arbitrary details.

```go
type Rule[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewRule"></a>
### func [NewRule](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L15>)

```go
func NewRule[T any](validate func(v T) error) Rule[T]
```

NewRule creates a new [Rule](<#Rule>) instance.

<a name="Rule[T].Validate"></a>
### func \(Rule\[T\]\) [Validate](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L36>)

```go
func (r Rule[T]) Validate(v T) error
```

Validate runs validation function on the provided value. It can handle different types of errors returned by the function:

- \*[RuleError](<#RuleError>), which details and [ErrorCode](<#ErrorCode>) are optionally extended with the ones defined by [Rule](<#Rule>).
- \*[PropertyError](<#PropertyError>), for each of its errors their [ErrorCode](<#ErrorCode>) is extended with the one defined by [Rule](<#Rule>).

By default, it will construct a new RuleError.

<a name="Rule[T].WithDescription"></a>
### func \(Rule\[T\]\) [WithDescription](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L92>)

```go
func (r Rule[T]) WithDescription(description string) Rule[T]
```

WithDescription adds a custom description to the rule. It is used to enhance the [RulePlan](<#RulePlan>), but otherwise does not appear in standard [RuleError.Error](<#RuleError.Error>) output.

<a name="Rule[T].WithDetails"></a>
### func \(Rule\[T\]\) [WithDetails](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L81>)

```go
func (r Rule[T]) WithDetails(format string, a ...any) Rule[T]
```

WithDetails adds details to the returned [RuleError](<#RuleError>) error message.

<details><summary>Example</summary>
<p>

You can use [govy.Rule.WithDetails](<#Rule.WithDetails>) to add additional details to the error message. This allows you to extend existing rules by adding your use case context. Let's give a regex validation some more clarity.

```go
package main

import (
	"fmt"
	"regexp"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Rules(rules.StringMatchRegexp(regexp.MustCompile("^(Tom|Jerry)$")).
				WithDetails("Teacher can be either Tom or Jerry :)")),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jake",
		Age:  51 * year,
	}

	err := v.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'name' with value 'Jake':
    - string must match regular expression: '^(Tom|Jerry)$'; Teacher can be either Tom or Jerry :)
```

</p>
</details>

<a name="Rule[T].WithErrorCode"></a>
### func \(Rule\[T\]\) [WithErrorCode](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L65>)

```go
func (r Rule[T]) WithErrorCode(code ErrorCode) Rule[T]
```

WithErrorCode sets the error code for the returned [RuleError](<#RuleError>).

<details><summary>Example</summary>
<p>

When testing, it can be tedious to always rely on error messages as these can change over time. Enter [govy.ErrorCode](<#ErrorCode>), which is a simple string type alias used to ease testing, but also potentially allow third parties to integrate with your validation results. Use [govy.Rule.WithErrorCode](<#Rule.WithErrorCode>) to associate [govy.ErrorCode](<#ErrorCode>) with a [govy.Rule](<#Rule>). Notice that our modified version of \[rules.StringMatchRegexp\] will now return a new [govy.ErrorCode](<#ErrorCode>). Predefined rules have [govy.ErrorCode](<#ErrorCode>) already associated with them. To view the list of predefined [govy.ErrorCode](<#ErrorCode>) checkout error\_codes.go file.

```go
package main

import (
	"fmt"
	"regexp"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Rules(rules.StringMatchRegexp(regexp.MustCompile("^(Tom|Jerry)$")).
				WithDetails("Teacher can be either Tom or Jerry :)").
				WithErrorCode("custom_code")),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jake",
		Age:  51 * year,
	}

	err := v.Validate(teacher)
	if err != nil {
		propertyErrors := err.Errors
		ruleErrors := propertyErrors[0].Errors
		fmt.Println(ruleErrors[0].Code)
	}

}
```

#### Output

```
custom_code
```

</p>
</details>

<a name="Rule[T].WithMessage"></a>
### func \(Rule\[T\]\) [WithMessage](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L71>)

```go
func (r Rule[T]) WithMessage(format string, a ...any) Rule[T]
```

WithMessage overrides the returned [RuleError](<#RuleError>) error message with message.

<a name="RuleError"></a>
## type [RuleError](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L179-L182>)

RuleError is the fundamental error container associated with a [Rule](<#Rule>).

```go
type RuleError struct {
    Message string    `json:"error"`
    Code    ErrorCode `json:"code,omitempty"`
}
```

<a name="NewRuleError"></a>
### func [NewRuleError](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L170>)

```go
func NewRuleError(message string, codes ...ErrorCode) *RuleError
```

NewRuleError creates a new [RuleError](<#RuleError>) with the given message and optional error codes. Error codes are added according to the rules defined by [RuleError.AddCode](<#RuleError.AddCode>).

<a name="RuleError.AddCode"></a>
### func \(\*RuleError\) [AddCode](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L195>)

```go
func (r *RuleError) AddCode(code ErrorCode) *RuleError
```

AddCode extends the [RuleError](<#RuleError>) with the given error code. Codes are prepended, the last code in chain is always the first one set. Example:

```
ruleError.AddCode("code").AddCode("another").AddCode("last")
```

This will result in 'last:another:code' [ErrorCode](<#ErrorCode>).

<a name="RuleError.Error"></a>
### func \(\*RuleError\) [Error](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L184>)

```go
func (r *RuleError) Error() string
```



<a name="RuleError.HideValue"></a>
### func \(\*RuleError\) [HideValue](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L201>)

```go
func (r *RuleError) HideValue(stringValue string) *RuleError
```

HideValue replaces all occurrences of a string in the \[RuleError.Message\] with a '\*' characters.

<a name="RulePlan"></a>
## type [RulePlan](<https://github.com/nobl9/govy/blob/main/pkg/govy/plan.go#L34-L41>)

RulePlan is a validation plan for a single [Rule](<#Rule>).

```go
type RulePlan struct {
    Description string    `json:"description"`
    Details     string    `json:"details,omitempty"`
    ErrorCode   ErrorCode `json:"errorCode,omitempty"`
    // Conditions are all the predicates set through [PropertyRules.When] and [Validator.When]
    // which had [WhenDescription] added to the [WhenOptions].
    Conditions []string `json:"conditions,omitempty"`
}
```

<a name="RuleSet"></a>
## type [RuleSet](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L113-L117>)

RuleSet allows defining a [Rule](<#Rule>) which aggregates multiple sub\-rules.

```go
type RuleSet[T any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

Sometimes it's useful to build a [govy.Rule](<#Rule>) using other rules. To do that we'll use [govy.RuleSet](<#RuleSet>) and [govy.NewRuleSet](<#NewRuleSet>) constructor. RuleSet is a simple container for multiple [govy.Rule](<#Rule>). It is later on unpacked and each [govy.RuleError](<#RuleError>) is reported separately. When [govy.RuleSet.WithErrorCode](<#RuleSet.WithErrorCode>) or [govy.RuleSet.WithDetails](<#RuleSet.WithDetails>) are used, error code and details are added to each [govy.RuleError](<#RuleError>). Note that govy uses similar syntax to wrapped errors in Go; a ':' delimiter is used to chain error codes together.

```go
package main

import (
	"fmt"
	"regexp"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	teacherNameRule := govy.NewRuleSet(
		rules.StringLength(1, 5),
		rules.StringMatchRegexp(regexp.MustCompile("^(Tom|Jerry)$")).
			WithDetails("Teacher can be either Tom or Jerry :)"),
	).
		WithErrorCode("teacher_name").
		WithDetails("I will add that to both rules!")

	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Rules(teacherNameRule),
	).WithName("Teacher")

	teacher := Teacher{
		Name: "Jonathan",
		Age:  51 * year,
	}

	err := v.Validate(teacher)
	if err != nil {
		propertyErrors := err.Errors
		ruleErrors := propertyErrors[0].Errors
		fmt.Printf("Error codes: %s, %s\n\n", ruleErrors[0].Code, ruleErrors[1].Code)
		fmt.Println(err)
	}

	// nolint: lll
	// Output:
	// Error codes: teacher_name:string_length, teacher_name:string_match_regexp
	//
	// Validation for Teacher has failed for the following properties:
	//   - 'name' with value 'Jonathan':
	//     - length must be between 1 and 5; I will add that to both rules!
	//     - string does not match regular expression: '^(Tom|Jerry)$'; Teacher can be either Tom or Jerry :); I will add that to both rules!
}
```

</p>
</details>

<a name="NewRuleSet"></a>
### func [NewRuleSet](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L108>)

```go
func NewRuleSet[T any](rules ...ruleInterface[T]) RuleSet[T]
```

NewRuleSet creates a new [RuleSet](<#RuleSet>) instance.

<a name="RuleSet[T].Validate"></a>
### func \(RuleSet\[T\]\) [Validate](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L122>)

```go
func (r RuleSet[T]) Validate(v T) error
```

Validate works the same way as [Rule.Validate](<#Rule.Validate>), except each aggregated rule is validated individually. The errors are aggregated and returned as a single error which serves as a container for them.

<a name="RuleSet[T].WithDetails"></a>
### func \(RuleSet\[T\]\) [WithDetails](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L156>)

```go
func (r RuleSet[T]) WithDetails(format string, a ...any) RuleSet[T]
```

WithDetails adds details to each returned [RuleError](<#RuleError>) error message.

<a name="RuleSet[T].WithErrorCode"></a>
### func \(RuleSet\[T\]\) [WithErrorCode](<https://github.com/nobl9/govy/blob/main/pkg/govy/rule.go#L150>)

```go
func (r RuleSet[T]) WithErrorCode(code ErrorCode) RuleSet[T]
```

WithErrorCode sets the error code for each returned [RuleError](<#RuleError>).

<a name="Transformer"></a>
## type [Transformer](<https://github.com/nobl9/govy/blob/main/pkg/govy/rules.go#L72>)

Transformer is a function that transforms a value of type T to a value of type N. If the transformation fails, the function should return an error.

```go
type Transformer[T, N any] func(T) (N, error)
```

<a name="Validator"></a>
## type [Validator](<https://github.com/nobl9/govy/blob/main/pkg/govy/validator.go#L20-L25>)

Validator is the top level validation entity. It serves as an aggregator for [PropertyRules](<#PropertyRules>). Typically, it represents a struct.

```go
type Validator[S any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

Bringing it all \(mostly\) together, let's create a fully fledged [govy.Validator](<#Validator>) for \[Teacher\].

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	universityValidation := govy.New(
		govy.For(func(u University) string { return u.Address }).
			WithName("address").
			Required(),
	)
	studentValidator := govy.New(
		govy.For(func(s Student) string { return s.Index }).
			WithName("index").
			Rules(rules.StringLength(9, 9)),
	)
	teacherValidator := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			Required().
			Rules(
				rules.StringNotEmpty(),
				rules.OneOf("Jake", "George")),
		govy.ForSlice(func(t Teacher) []Student { return t.Students }).
			WithName("students").
			Rules(
				rules.SliceMaxLength[[]Student](2),
				rules.SliceUnique(func(v Student) string { return v.Index })).
			IncludeForEach(studentValidator),
		govy.For(func(t Teacher) University { return t.University }).
			WithName("university").
			Include(universityValidation),
	).When(func(t Teacher) bool { return t.Age < 50 })

	teacher := Teacher{
		Name: "John",
		Students: []Student{
			{Index: "918230014"},
			{Index: "9182300123"},
			{Index: "918230014"},
		},
		University: University{
			Name:    "Poznan University of Technology",
			Address: "",
		},
	}

	err := teacherValidator.WithName("John").Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for John has failed for the following properties:
  - 'name' with value 'John':
    - must be one of [Jake, George]
  - 'students' with value '[{"index":"918230014"},{"index":"9182300123"},{"index":"918230014"}]':
    - length must be less than or equal to 2
    - elements are not unique, index 0 collides with index 2
  - 'students[1].index' with value '9182300123':
    - length must be between 9 and 9
  - 'university.address':
    - property is required but was empty
```

</p>
</details>

<details><summary>Example (Branching Pattern)</summary>
<p>

When dealing with properties that should only be validated if a certain other property has specific value, it's recommended to use [govy.PropertyRules.When](<#PropertyRules.When>) and [govy.PropertyRules.Include](<#PropertyRules.Include>) to separate validation paths into non\-overlapping branches.

Notice how in the below example \[File.Format\] is the common, shared property between \[CSV\] and \[JSON\] files. We define separate [govy.Validator](<#Validator>) for \[CSV\] and \[JSON\] and use [govy.PropertyRules.When](<#PropertyRules.When>) to only validate their included [govy.Validator](<#Validator>) if the correct \[File.Format\] is provided.

```go
package main

import (
	"fmt"
	"regexp"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

func main() {
	type (
		CSV struct {
			Separator string `json:"separator"`
		}
		JSON struct {
			Indent string `json:"indent"`
		}
		File struct {
			Format string `json:"format"`
			CSV    *CSV   `json:"csv,omitempty"`
			JSON   *JSON  `json:"json,omitempty"`
		}
	)

	csvValidation := govy.New(
		govy.For(func(c CSV) string { return c.Separator }).
			WithName("separator").
			Required().
			Rules(rules.OneOf(",", ";")),
	)

	jsonValidation := govy.New(
		govy.For(func(j JSON) string { return j.Indent }).
			WithName("indent").
			Required().
			Rules(rules.StringMatchRegexp(regexp.MustCompile(`^\s*$`))),
	)

	fileValidation := govy.New(
		govy.ForPointer(func(f File) *CSV { return f.CSV }).
			When(func(f File) bool { return f.Format == "csv" }).
			Include(csvValidation),
		govy.ForPointer(func(f File) *JSON { return f.JSON }).
			When(func(f File) bool { return f.Format == "json" }).
			Include(jsonValidation),
		govy.For(func(f File) string { return f.Format }).
			WithName("format").
			Required().
			Rules(rules.OneOf("csv", "json")),
	).WithName("File")

	file := File{
		Format: "json",
		CSV:    nil,
		JSON: &JSON{
			Indent: "invalid",
		},
	}

	err := fileValidation.Validate(file)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for File has failed for the following properties:
  - 'indent' with value 'invalid':
    - string must match regular expression: '^\s*$'
```

</p>
</details>

<a name="New"></a>
### func [New](<https://github.com/nobl9/govy/blob/main/pkg/govy/validator.go#L13>)

```go
func New[S any](props ...propertyRulesInterface[S]) Validator[S]
```

New creates a new [Validator](<#Validator>) aggregating the provided property rules.

<details><summary>Example</summary>
<p>

In order to create a new [govy.Validator](<#Validator>) use [govy.New](<#New>) constructor. Let's define simple [govy.PropertyRules](<#PropertyRules>) for \[Teacher.Name\]. For now, it will be always failing.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			Rules(govy.NewRule(func(name string) error { return fmt.Errorf("always fails") })),
	)

	err := v.Validate(Teacher{})
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation has failed for the following properties:
  - always fails
```

</p>
</details>

<a name="Validator[S].InferName"></a>
### func \(Validator\[S\]\) [InferName](<https://github.com/nobl9/govy/blob/main/pkg/govy/validator.go#L43>)

```go
func (v Validator[S]) InferName() Validator[S]
```

InferName will set the name of the [Validator](<#Validator>) to its type S. If the name was already set through [Validator.WithName](<#Validator.WithName>), it will not be overridden. It does not use the same inference mechanisms as \[PropertyRules.InferName\], it simply checks the [Validator](<#Validator>) type parameter using reflection.

<a name="Validator[S].Validate"></a>
### func \(Validator\[S\]\) [Validate](<https://github.com/nobl9/govy/blob/main/pkg/govy/validator.go#L58>)

```go
func (v Validator[S]) Validate(st S) *ValidatorError
```

Validate will first evaluate predicates before validating any rules. If any predicate does not pass the validation won't be executed \(returns nil\). All errors returned by property rules will be aggregated and wrapped in [ValidatorError](<#ValidatorError>).

<a name="Validator[S].When"></a>
### func \(Validator\[S\]\) [When](<https://github.com/nobl9/govy/blob/main/pkg/govy/validator.go#L34>)

```go
func (v Validator[S]) When(predicate Predicate[S], opts ...WhenOptions) Validator[S]
```

When accepts predicates which will be evaluated BEFORE [Validator](<#Validator>) validates ANY rules.

<details><summary>Example</summary>
<p>

[govy.Validator](<#Validator>) rules can be evaluated on condition, to specify the predicate use [govy.Validator.When](<#Validator.When>) function.

In this example, validation for \[Teacher\] instance will only be evaluated if the \[Teacher.Age\] property is less than 50 years.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

const year = 24 * 365 * time.Hour

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			Rules(govy.NewRule(func(name string) error { return fmt.Errorf("always fails") })),
	).
		When(func(t Teacher) bool { return t.Age < (50 * year) })

	// Prepare teachers.
	teacherTom := Teacher{
		Name: "Tom",
		Age:  51 * year,
	}
	teacherJerry := Teacher{
		Name: "Jerry",
		Age:  30 * year,
	}

	// Run validation.
	err := v.Validate(teacherTom)
	if err != nil {
		fmt.Println(err.WithName("Tom"))
	}
	err = v.Validate(teacherJerry)
	if err != nil {
		fmt.Println(err.WithName("Jerry"))
	}

}
```

#### Output

```
Validation for Jerry has failed for the following properties:
  - always fails
```

</p>
</details>

<a name="Validator[S].WithName"></a>
### func \(Validator\[S\]\) [WithName](<https://github.com/nobl9/govy/blob/main/pkg/govy/validator.go#L28>)

```go
func (v Validator[S]) WithName(name string) Validator[S]
```

WithName when a rule fails will pass the provided name to [ValidatorError.WithName](<#ValidatorError.WithName>).

<details><summary>Example</summary>
<p>

To associate [govy.Validator](<#Validator>) with an entity name use [govy.Validator.WithName](<#Validator.WithName>) function. When any of the rules fails, the error will contain the entity name you've provided.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			Rules(govy.NewRule(func(name string) error { return fmt.Errorf("always fails") })),
	).WithName("Teacher")

	err := v.Validate(Teacher{})
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - always fails
```

</p>
</details>

<a name="ValidatorError"></a>
## type [ValidatorError](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L23-L26>)

ValidatorError is the top\-level error type for validation errors. It aggregates the property errors of [Validator](<#Validator>).

```go
type ValidatorError struct {
    Errors PropertyErrors `json:"errors"`
    Name   string         `json:"name"`
}
```

<a name="NewValidatorError"></a>
### func [NewValidatorError](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L17>)

```go
func NewValidatorError(errs PropertyErrors) *ValidatorError
```



<a name="ValidatorError.Error"></a>
### func \(\*ValidatorError\) [Error](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L34>)

```go
func (e *ValidatorError) Error() string
```



<a name="ValidatorError.WithName"></a>
### func \(\*ValidatorError\) [WithName](<https://github.com/nobl9/govy/blob/main/pkg/govy/errors.go#L29>)

```go
func (e *ValidatorError) WithName(name string) *ValidatorError
```

WithName sets the \[ValidatorError.Name\] field.

<details><summary>Example</summary>
<p>

You can also add [govy.Validator](<#Validator>) name during runtime, by calling [govy.ValidatorError.WithName](<#ValidatorError.WithName>) function on the returned error.

NOTE: We left the previous "Teacher" name assignment, to demonstrate that the [govy.ValidatorError.WithName](<#ValidatorError.WithName>) function call will shadow it.

NOTE: This would also work:

```
err := v.WithName("Jake").Validate(Teacher{})
```

govy, aside from errors handling, tries to follow immutability principle. Calling any method on [govy.Validator](<#Validator>) will not change its declared instance, but rather create a copy of it.

```go
package main

import (
	"fmt"
	"time"

	"github.com/nobl9/govy/pkg/govy"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			Rules(govy.NewRule(func(name string) error { return fmt.Errorf("always fails") })),
	).WithName("Teacher")

	err := v.Validate(Teacher{})
	if err != nil {
		fmt.Println(err.WithName("Jake"))
	}

}
```

#### Output

```
Validation for Jake has failed for the following properties:
  - always fails
```

</p>
</details>

<a name="ValidatorPlan"></a>
## type [ValidatorPlan](<https://github.com/nobl9/govy/blob/main/pkg/govy/plan.go#L12-L15>)

ValidatorPlan is a validation plan for a single [Validator](<#Validator>).

```go
type ValidatorPlan struct {
    Name       string         `json:"name,omitempty"`
    Properties []PropertyPlan `json:"properties"`
}
```

<a name="Plan"></a>
### func [Plan](<https://github.com/nobl9/govy/blob/main/pkg/govy/plan.go#L50>)

```go
func Plan[S any](v Validator[S]) *ValidatorPlan
```

Plan creates a validation plan for the provided [Validator](<#Validator>). Each property is represented by a [PropertyPlan](<#PropertyPlan>) which aggregates its every [RulePlan](<#RulePlan>). If a property does not have any rules, it won't be included in the result.

<details><summary>Example</summary>
<p>

When documenting an API it's often a struggle to keep consistency between the code and documentation we write for it. What If your code could be self\-descriptive? Specifically, what If we could generate documentation out of our validation rules? We can achieve that by using [govy.Plan](<#Plan>) function\!

There are multiple ways to improve the generated documentation:

- Use [govy.PropertyRules.WithExamples](<#PropertyRules.WithExamples>) to provide a list of example values for the property.
- Use [govy.Rule.WithDescription](<#Rule.WithDescription>) to provide a plan\-only description for your rule. For builtin rules, the description is already provided.
- Use [govy.WhenDescription](<#WhenDescription>) to provide a plan\-only description for your when conditions.

```go
package main

import (
	"encoding/json"
	"os"
	"time"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name       string        `json:"name"`
	Age        time.Duration `json:"age"`
	Students   []Student     `json:"students"`
	MiddleName *string       `json:"middleName,omitempty"`
	University University    `json:"university"`
}

type University struct {
	Name    string `json:"name"`
	Address string `json:"address"`
}

type Student struct {
	Index string `json:"index"`
}

func main() {
	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			WithName("name").
			WithExamples("Jake", "John").
			When(
				func(t Teacher) bool { return t.Name == "Jerry" },
				govy.WhenDescription("name is Jerry"),
			).
			Rules(
				rules.NEQ("Jerry").
					WithDetails("Jerry is just a name!"),
			),
	).WithName("Teacher")

	properties := govy.Plan(v)
	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	_ = enc.Encode(properties)

}
```

#### Output

```
{
  "name": "Teacher",
  "properties": [
    {
      "path": "$.name",
      "type": "string",
      "examples": [
        "Jake",
        "John"
      ],
      "rules": [
        {
          "description": "should be not equal to 'Jerry'",
          "details": "Jerry is just a name!",
          "errorCode": "not_equal_to",
          "conditions": [
            "name is Jerry"
          ]
        }
      ]
    }
  ]
}
```

</p>
</details>

<a name="WhenOptions"></a>
## type [WhenOptions](<https://github.com/nobl9/govy/blob/main/pkg/govy/predicate.go#L6-L8>)

WhenOptions defines optional parameters for the When conditions.

```go
type WhenOptions struct {
    // contains filtered or unexported fields
}
```

<a name="WhenDescription"></a>
### func [WhenDescription](<https://github.com/nobl9/govy/blob/main/pkg/govy/predicate.go#L11>)

```go
func WhenDescription(format string, a ...interface{}) WhenOptions
```

WhenDescription sets the description for the When condition.

# govyconfig

```go
import "github.com/nobl9/govy/pkg/govyconfig"
```

Package govyconfig defines configuration functions for govy. It also holds internal, shared state for the library. The functions defined by govyconfig can be safely called concurrently. However, bear in mind that it is still important to take care of the order of calls to both govy and govyconfig functions.

For instance calling \[govy.For\] before [SetNameInferMode](<#SetNameInferMode>) will not have any effect, for the \[govy.PropertyRules\] instance created with \[govy.For\].

## Index

- [func GetInferredName\(file string, line int\) string](<#GetInferredName>)
- [func GetNameInferIncludeTestFiles\(\) bool](<#GetNameInferIncludeTestFiles>)
- [func NameInferDefaultRule\(fieldName, tagValue string\) string](<#NameInferDefaultRule>)
- [func SetInferredName\(loc InferredName\)](<#SetInferredName>)
- [func SetLogLevel\(level slog.Level\)](<#SetLogLevel>)
- [func SetNameInferFunc\(rule NameInferFunc\)](<#SetNameInferFunc>)
- [func SetNameInferIncludeTestFiles\(inc bool\)](<#SetNameInferIncludeTestFiles>)
- [func SetNameInferMode\(mode NameInferMode\)](<#SetNameInferMode>)
- [type InferredName](<#InferredName>)
- [type NameInferFunc](<#NameInferFunc>)
  - [func GetNameInferFunc\(\) NameInferFunc](<#GetNameInferFunc>)
- [type NameInferMode](<#NameInferMode>)
  - [func GetNameInferMode\(\) NameInferMode](<#GetNameInferMode>)


<a name="GetInferredName"></a>
## func [GetInferredName](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L54>)

```go
func GetInferredName(file string, line int) string
```

GetInferredName returns the inferred property name for the given file and line. The name has to be first set using [SetInferredName](<#SetInferredName>). It is primarily exported for govy to utilize when NameInferModeGenerate mode is set.

<a name="GetNameInferIncludeTestFiles"></a>
## func [GetNameInferIncludeTestFiles](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L148>)

```go
func GetNameInferIncludeTestFiles() bool
```

GetNameInferIncludeTestFiles returns whether to include test files in name inference mechanism.

<a name="NameInferDefaultRule"></a>
## func [NameInferDefaultRule](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L126>)

```go
func NameInferDefaultRule(fieldName, tagValue string) string
```

NameInferDefaultRule is the default rule for inferring field names from struct tags, it looks for json and yaml tags, preferring json if both are set.

<a name="SetInferredName"></a>
## func [SetInferredName](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L45>)

```go
func SetInferredName(loc InferredName)
```

SetInferredName sets the inferred property name for the given file and line. Once it's registered it can be retrieved using [GetInferredName](<#GetInferredName>). It is primarily exported for code generation utility of govy which runs in NameInferModeGenerate.

<a name="SetLogLevel"></a>
## func [SetLogLevel](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L66>)

```go
func SetLogLevel(level slog.Level)
```

SetLogLevel sets the logging level for \[slog.Logger\] used by govy. It's safe to call this function concurrently.

<a name="SetNameInferFunc"></a>
## func [SetNameInferFunc](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L107>)

```go
func SetNameInferFunc(rule NameInferFunc)
```

SetNameInferFunc sets the rule for inferring field names from struct tags. It overrides the default rule [NameInferDefaultRule](<#NameInferDefaultRule>). It's safe to call this function concurrently.

<a name="SetNameInferIncludeTestFiles"></a>
## func [SetNameInferIncludeTestFiles](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L141>)

```go
func SetNameInferIncludeTestFiles(inc bool)
```

SetNameInferIncludeTestFiles sets whether to include test files in name inference mechanism.

<a name="SetNameInferMode"></a>
## func [SetNameInferMode](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L92>)

```go
func SetNameInferMode(mode NameInferMode)
```

SetNameInferMode sets the mode of property names' inference. It overrides the default mode [NameInferModeDisable](<#NameInferModeDisable>). It's safe to call this function concurrently.

<details><summary>Example</summary>
<p>

In the interactive tutorial for govy, we've been using \[govy.PropertyRules.WithName\] to provide the name for our properties.

Ideally, we'd want to make sure the names govy assigns to each property, match the name of the real\-world struct representation that the user interacts with. Go uses struct tags to achieve just that, and libraries like [encoding/json](<https://pkg.go.dev/encoding/json/>) use their values to encode/decode structs. Unfortunately, there's no easy way to tell what exact property we're returning from \[govy.PropertyGetter\].

To solve this problem, govy provides a way to infer the name of the property \(with a catch\). The catch being that the name inference mechanism needs to parse the whole modules' AST. This can be a performance hit, especially for large projects if not done properly.

By default govy WILL NOT attempt to infer ANY property names.

So, how do we do that properly? It depends on the [govyconfig.NameInferMode](<#NameInferMode>) used:

- [govyconfig.NameInferModeDisable](<#NameInferModeDisable>), name inference is disabled \(default\), nothing to do here
- [govyconfig.NameInferModeRuntime](<#NameInferModeDisable>), the name is inferred during runtime, whenever \[govy.For\] is called. This is the most flexible option, but also the slowest. However, If you make sure that \[govy.PropertyRules\] are created only once and don't mind the initial/startup performance hit, this should be enough for you.
- [govyconfig.NameInferModeGenerate](<#NameInferModeDisable>), the name is inferred during code generation. This mode requires you to run the cmd/nameinfer BEFORE you run your code. It will generate a file with inferred names for your structs which automatically registers these names using [govyconfig.SetInferredName](<#SetInferredName>).

Since this tutorial is run as a test, we need to explicitly instruct govy to infer names from test files. In order to do that, we use [govyconfig.SetNameInferIncludeTestFiles](<#SetNameInferIncludeTestFiles>).

```go
package main

import (
	"fmt"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/govyconfig"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name string `json:"name"`
}

func main() {
	govyconfig.SetNameInferIncludeTestFiles(true)
	govyconfig.SetNameInferMode(govyconfig.NameInferModeRuntime)
	defer govyconfig.SetNameInferIncludeTestFiles(false)
	defer govyconfig.SetNameInferMode(govyconfig.NameInferModeDisable)

	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			Rules(rules.EQ("Jerry")),
	).WithName("Teacher")

	teacher := Teacher{Name: "Tom"}
	err := v.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - 'name' with value 'Tom':
    - should be equal to 'Jerry'
```

</p>
</details>

<details><summary>Example (Invalid Usage)</summary>
<p>

Beware where you call [govyconfig.SetNameInferMode](<#SetNameInferMode>). If you call it after the \[govy.For\] has been called, it won't do anything. This is because the name inference is done during the creation of \[govy.PropertyRules\].

```go
package main

import (
	"fmt"

	"github.com/nobl9/govy/pkg/govy"
	"github.com/nobl9/govy/pkg/govyconfig"
	"github.com/nobl9/govy/pkg/rules"
)

type Teacher struct {
	Name string `json:"name"`
}

func main() {
	govyconfig.SetNameInferIncludeTestFiles(true)
	defer govyconfig.SetNameInferIncludeTestFiles(false)

	v := govy.New(
		govy.For(func(t Teacher) string { return t.Name }).
			Rules(rules.EQ("Jerry")),
	).WithName("Teacher")

	govyconfig.SetNameInferMode(govyconfig.NameInferModeRuntime)
	defer govyconfig.SetNameInferMode(govyconfig.NameInferModeDisable)

	teacher := Teacher{Name: "Tom"}
	err := v.Validate(teacher)
	if err != nil {
		fmt.Println(err)
	}

}
```

#### Output

```
Validation for Teacher has failed for the following properties:
  - should be equal to 'Jerry'
```

</p>
</details>

<a name="InferredName"></a>
## type [InferredName](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L24-L31>)

InferredName represents an inferred property name.

```go
type InferredName struct {
    // Name is the inferred property name.
    Name string
    // File is the relative path to the file where the [govy.PropertyRules.For] is detected.
    File string
    // Line is the line number in the File where the [govy.PropertyRules.For] is detected.
    Line int
}
```

<a name="NameInferFunc"></a>
## type [NameInferFunc](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L122>)

NameInferFunc is a function blueprint for inferring property names. It is only called for struct fields. Tag value is the raw value of the struct tag, it needs to be parsed with [reflect.StructTag](<https://pkg.go.dev/reflect/#StructTag>).

```go
type NameInferFunc func(fieldName, tagValue string) string
```

<a name="GetNameInferFunc"></a>
### func [GetNameInferFunc](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L113>)

```go
func GetNameInferFunc() NameInferFunc
```



<a name="NameInferMode"></a>
## type [NameInferMode](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L71>)

NameInferMode defines a mode of property names' inference.

```go
type NameInferMode int
```

<a name="NameInferModeDisable"></a>

```go
const (
    // NameInferModeDisable disables property names' inference.
    // It is the default mode.
    NameInferModeDisable NameInferMode = iota
    // NameInferModeRuntime infers property names' during runtime,
    // whenever For, ForSlice, ForPointer or ForMap are created.
    // If you're not reusing these [govy.PropertyRules], but rather creating them dynamically,
    // beware of significant performance cost of the inference mechanism.
    NameInferModeRuntime
    // NameInferModeGenerate does the heavy lifting of inferring property names
    // in a separate step which involves code generation.
    // When creating new [govy.PropertyRules], the only performance hit is due to the
    // usage of [runtime] package which helps us get the caller frame details.
    NameInferModeGenerate
)
```

<a name="GetNameInferMode"></a>
### func [GetNameInferMode](<https://github.com/nobl9/govy/blob/main/pkg/govyconfig/config.go#L98>)

```go
func GetNameInferMode() NameInferMode
```



# rules

```go
import "github.com/nobl9/govy/pkg/rules"
```

Package rules provides predefined rules for common validation scenarios.

## Index

- [Constants](<#constants>)
- [func DurationPrecision\(precision time.Duration\) govy.Rule\[time.Duration\]](<#DurationPrecision>)
- [func EQ\[T comparable\]\(compared T\) govy.Rule\[T\]](<#EQ>)
- [func Forbidden\[T any\]\(\) govy.Rule\[T\]](<#Forbidden>)
- [func GT\[T constraints.Ordered\]\(compared T\) govy.Rule\[T\]](<#GT>)
- [func GTE\[T constraints.Ordered\]\(compared T\) govy.Rule\[T\]](<#GTE>)
- [func LT\[T constraints.Ordered\]\(compared T\) govy.Rule\[T\]](<#LT>)
- [func LTE\[T constraints.Ordered\]\(compared T\) govy.Rule\[T\]](<#LTE>)
- [func MapLength\[M \~map\[K\]V, K comparable, V any\]\(lower, upper int\) govy.Rule\[M\]](<#MapLength>)
- [func MapMaxLength\[M \~map\[K\]V, K comparable, V any\]\(limit int\) govy.Rule\[M\]](<#MapMaxLength>)
- [func MapMinLength\[M \~map\[K\]V, K comparable, V any\]\(limit int\) govy.Rule\[M\]](<#MapMinLength>)
- [func MutuallyExclusive\[S any\]\(required bool, getters map\[string\]func\(s S\) any\) govy.Rule\[S\]](<#MutuallyExclusive>)
- [func NEQ\[T comparable\]\(compared T\) govy.Rule\[T\]](<#NEQ>)
- [func OneOf\[T comparable\]\(values ...T\) govy.Rule\[T\]](<#OneOf>)
- [func Required\[T any\]\(\) govy.Rule\[T\]](<#Required>)
- [func SliceLength\[S \~\[\]E, E any\]\(lower, upper int\) govy.Rule\[S\]](<#SliceLength>)
- [func SliceMaxLength\[S \~\[\]E, E any\]\(limit int\) govy.Rule\[S\]](<#SliceMaxLength>)
- [func SliceMinLength\[S \~\[\]E, E any\]\(limit int\) govy.Rule\[S\]](<#SliceMinLength>)
- [func SliceUnique\[S \[\]V, V any, H comparable\]\(hashFunc HashFunction\[V, H\], constraints ...string\) govy.Rule\[S\]](<#SliceUnique>)
- [func StringASCII\(\) govy.Rule\[string\]](<#StringASCII>)
- [func StringContains\(substrings ...string\) govy.Rule\[string\]](<#StringContains>)
- [func StringDNSLabel\(\) govy.RuleSet\[string\]](<#StringDNSLabel>)
- [func StringDenyRegexp\(re \*regexp.Regexp, examples ...string\) govy.Rule\[string\]](<#StringDenyRegexp>)
- [func StringIsTitle\(\) govy.Rule\[string\]](<#StringIsTitle>)
- [func StringJSON\(\) govy.Rule\[string\]](<#StringJSON>)
- [func StringLength\(lower, upper int\) govy.Rule\[string\]](<#StringLength>)
- [func StringMatchRegexp\(re \*regexp.Regexp, examples ...string\) govy.Rule\[string\]](<#StringMatchRegexp>)
- [func StringMaxLength\(limit int\) govy.Rule\[string\]](<#StringMaxLength>)
- [func StringMinLength\(limit int\) govy.Rule\[string\]](<#StringMinLength>)
- [func StringNotEmpty\(\) govy.Rule\[string\]](<#StringNotEmpty>)
- [func StringStartsWith\(prefixes ...string\) govy.Rule\[string\]](<#StringStartsWith>)
- [func StringURL\(\) govy.Rule\[string\]](<#StringURL>)
- [func StringUUID\(\) govy.Rule\[string\]](<#StringUUID>)
- [func URL\(\) govy.Rule\[\*url.URL\]](<#URL>)
- [type HashFunction](<#HashFunction>)
  - [func HashFuncSelf\[H comparable\]\(\) HashFunction\[H, H\]](<#HashFuncSelf>)


## Constants

<a name="ErrorCodeRequired"></a>

```go
const (
    ErrorCodeRequired             govy.ErrorCode = internal.RequiredErrorCodeString
    ErrorCodeForbidden            govy.ErrorCode = "forbidden"
    ErrorCodeEqualTo              govy.ErrorCode = "equal_to"
    ErrorCodeNotEqualTo           govy.ErrorCode = "not_equal_to"
    ErrorCodeGreaterThan          govy.ErrorCode = "greater_than"
    ErrorCodeGreaterThanOrEqualTo govy.ErrorCode = "greater_than_or_equal_to"
    ErrorCodeLessThan             govy.ErrorCode = "less_than"
    ErrorCodeLessThanOrEqualTo    govy.ErrorCode = "less_than_or_equal_to"
    ErrorCodeStringNotEmpty       govy.ErrorCode = "string_not_empty"
    ErrorCodeStringMatchRegexp    govy.ErrorCode = "string_match_regexp"
    ErrorCodeStringDenyRegexp     govy.ErrorCode = "string_deny_regexp"
    ErrorCodeStringIsDNSLabel     govy.ErrorCode = "string_is_dns_label"
    ErrorCodeStringASCII          govy.ErrorCode = "string_ascii"
    ErrorCodeStringURL            govy.ErrorCode = "string_url"
    ErrorCodeStringUUID           govy.ErrorCode = "string_uuid"
    ErrorCodeStringJSON           govy.ErrorCode = "string_json"
    ErrorCodeStringContains       govy.ErrorCode = "string_contains"
    ErrorCodeStringStartsWith     govy.ErrorCode = "string_starts_with"
    ErrorCodeStringLength         govy.ErrorCode = "string_length"
    ErrorCodeStringMinLength      govy.ErrorCode = "string_min_length"
    ErrorCodeStringMaxLength      govy.ErrorCode = "string_max_length"
    ErrorCodeStringIsTitle        govy.ErrorCode = "string_is_title"
    ErrorCodeSliceLength          govy.ErrorCode = "slice_length"
    ErrorCodeSliceMinLength       govy.ErrorCode = "slice_min_length"
    ErrorCodeSliceMaxLength       govy.ErrorCode = "slice_max_length"
    ErrorCodeMapLength            govy.ErrorCode = "map_length"
    ErrorCodeMapMinLength         govy.ErrorCode = "map_min_length"
    ErrorCodeMapMaxLength         govy.ErrorCode = "map_max_length"
    ErrorCodeOneOf                govy.ErrorCode = "one_of"
    ErrorCodeMutuallyExclusive    govy.ErrorCode = "mutually_exclusive"
    ErrorCodeSliceUnique          govy.ErrorCode = "slice_unique"
    ErrorCodeURL                  govy.ErrorCode = "url"
    ErrorCodeDurationPrecision    govy.ErrorCode = "duration_precision"
)
```

<a name="DurationPrecision"></a>
## func [DurationPrecision](<https://github.com/nobl9/govy/blob/main/pkg/rules/duration.go#L11>)

```go
func DurationPrecision(precision time.Duration) govy.Rule[time.Duration]
```



<a name="EQ"></a>
## func [EQ](<https://github.com/nobl9/govy/blob/main/pkg/rules/comparable.go#L12>)

```go
func EQ[T comparable](compared T) govy.Rule[T]
```



<a name="Forbidden"></a>
## func [Forbidden](<https://github.com/nobl9/govy/blob/main/pkg/rules/forbidden.go#L10>)

```go
func Forbidden[T any]() govy.Rule[T]
```



<a name="GT"></a>
## func [GT](<https://github.com/nobl9/govy/blob/main/pkg/rules/comparable.go#L36>)

```go
func GT[T constraints.Ordered](compared T) govy.Rule[T]
```



<a name="GTE"></a>
## func [GTE](<https://github.com/nobl9/govy/blob/main/pkg/rules/comparable.go#L41>)

```go
func GTE[T constraints.Ordered](compared T) govy.Rule[T]
```



<a name="LT"></a>
## func [LT](<https://github.com/nobl9/govy/blob/main/pkg/rules/comparable.go#L46>)

```go
func LT[T constraints.Ordered](compared T) govy.Rule[T]
```



<a name="LTE"></a>
## func [LTE](<https://github.com/nobl9/govy/blob/main/pkg/rules/comparable.go#L51>)

```go
func LTE[T constraints.Ordered](compared T) govy.Rule[T]
```



<a name="MapLength"></a>
## func [MapLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L89>)

```go
func MapLength[M ~map[K]V, K comparable, V any](lower, upper int) govy.Rule[M]
```



<a name="MapMaxLength"></a>
## func [MapMaxLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L115>)

```go
func MapMaxLength[M ~map[K]V, K comparable, V any](limit int) govy.Rule[M]
```



<a name="MapMinLength"></a>
## func [MapMinLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L102>)

```go
func MapMinLength[M ~map[K]V, K comparable, V any](limit int) govy.Rule[M]
```



<a name="MutuallyExclusive"></a>
## func [MutuallyExclusive](<https://github.com/nobl9/govy/blob/main/pkg/rules/one_of.go#L35>)

```go
func MutuallyExclusive[S any](required bool, getters map[string]func(s S) any) govy.Rule[S]
```

MutuallyExclusive checks if properties are mutually exclusive. This means, exactly one of the properties can be provided. If required is true, then a single non\-empty property is required.

<a name="NEQ"></a>
## func [NEQ](<https://github.com/nobl9/govy/blob/main/pkg/rules/comparable.go#L24>)

```go
func NEQ[T comparable](compared T) govy.Rule[T]
```



<a name="OneOf"></a>
## func [OneOf](<https://github.com/nobl9/govy/blob/main/pkg/rules/one_of.go#L15>)

```go
func OneOf[T comparable](values ...T) govy.Rule[T]
```



<a name="Required"></a>
## func [Required](<https://github.com/nobl9/govy/blob/main/pkg/rules/required.go#L8>)

```go
func Required[T any]() govy.Rule[T]
```



<a name="SliceLength"></a>
## func [SliceLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L50>)

```go
func SliceLength[S ~[]E, E any](lower, upper int) govy.Rule[S]
```



<a name="SliceMaxLength"></a>
## func [SliceMaxLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L76>)

```go
func SliceMaxLength[S ~[]E, E any](limit int) govy.Rule[S]
```



<a name="SliceMinLength"></a>
## func [SliceMinLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L63>)

```go
func SliceMinLength[S ~[]E, E any](limit int) govy.Rule[S]
```



<a name="SliceUnique"></a>
## func [SliceUnique](<https://github.com/nobl9/govy/blob/main/pkg/rules/unique.go#L22>)

```go
func SliceUnique[S []V, V any, H comparable](hashFunc HashFunction[V, H], constraints ...string) govy.Rule[S]
```

SliceUnique validates that a slice contains unique elements based on a provided HashFunction. You can optionally specify constraints which will be included in the error message to further clarify the reason for breaking uniqueness.

<a name="StringASCII"></a>
## func [StringASCII](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L83>)

```go
func StringASCII() govy.Rule[string]
```



<a name="StringContains"></a>
## func [StringContains](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L111>)

```go
func StringContains(substrings ...string) govy.Rule[string]
```



<a name="StringDNSLabel"></a>
## func [StringDNSLabel](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L60>)

```go
func StringDNSLabel() govy.RuleSet[string]
```



<a name="StringDenyRegexp"></a>
## func [StringDenyRegexp](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L42>)

```go
func StringDenyRegexp(re *regexp.Regexp, examples ...string) govy.Rule[string]
```



<a name="StringIsTitle"></a>
## func [StringIsTitle](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L154>)

```go
func StringIsTitle() govy.Rule[string]
```



<a name="StringJSON"></a>
## func [StringJSON](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L99>)

```go
func StringJSON() govy.Rule[string]
```



<a name="StringLength"></a>
## func [StringLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L11>)

```go
func StringLength(lower, upper int) govy.Rule[string]
```



<a name="StringMatchRegexp"></a>
## func [StringMatchRegexp](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L27>)

```go
func StringMatchRegexp(re *regexp.Regexp, examples ...string) govy.Rule[string]
```



<a name="StringMaxLength"></a>
## func [StringMaxLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L37>)

```go
func StringMaxLength(limit int) govy.Rule[string]
```



<a name="StringMinLength"></a>
## func [StringMinLength](<https://github.com/nobl9/govy/blob/main/pkg/rules/length.go#L24>)

```go
func StringMinLength(limit int) govy.Rule[string]
```



<a name="StringNotEmpty"></a>
## func [StringNotEmpty](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L15>)

```go
func StringNotEmpty() govy.Rule[string]
```



<a name="StringStartsWith"></a>
## func [StringStartsWith](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L130>)

```go
func StringStartsWith(prefixes ...string) govy.Rule[string]
```



<a name="StringURL"></a>
## func [StringURL](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L87>)

```go
func StringURL() govy.Rule[string]
```



<a name="StringUUID"></a>
## func [StringUUID](<https://github.com/nobl9/govy/blob/main/pkg/rules/string.go#L72>)

```go
func StringUUID() govy.Rule[string]
```



<a name="URL"></a>
## func [URL](<https://github.com/nobl9/govy/blob/main/pkg/rules/url.go#L10>)

```go
func URL() govy.Rule[*url.URL]
```



<a name="HashFunction"></a>
## type [HashFunction](<https://github.com/nobl9/govy/blob/main/pkg/rules/unique.go#L11>)

HashFunction accepts a value and returns a comparable hash.

```go
type HashFunction[V any, H comparable] func(v V) H
```

<a name="HashFuncSelf"></a>
### func [HashFuncSelf](<https://github.com/nobl9/govy/blob/main/pkg/rules/unique.go#L15>)

```go
func HashFuncSelf[H comparable]() HashFunction[H, H]
```

HashFuncSelf returns a HashFunction which returns its input value as a hash itself. The value must be comparable.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
